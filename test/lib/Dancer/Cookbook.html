<html><head><title>Dancer::Cookbook</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.22,
  using Pod::Simple::PullParser v3.22,
  under Perl v5.014001 at Sun Jun 24 19:07:13 2012 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#BEGINNER%27S_DANCE'>BEGINNER&#39;S DANCE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Your_first_Dancer_web_app'>Your first Dancer web app</a>
    <li class='indexItem indexItem2'><a href='#Starting_a_Dancer_project'>Starting a Dancer project</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DANCE_ROUTINES%3A_ROUTES'>DANCE ROUTINES: ROUTES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Declaring_routes'>Declaring routes</a>
    <li class='indexItem indexItem2'><a href='#Handling_multiple_HTTP_request_methods'>Handling multiple HTTP request methods</a>
    <li class='indexItem indexItem2'><a href='#Retrieving_request_parameters'>Retrieving request parameters</a>
    <li class='indexItem indexItem2'><a href='#Named_parameters_in_route_path_declarations'>Named parameters in route path declarations</a>
    <li class='indexItem indexItem2'><a href='#Wildcard_path_matching_and_splat'>Wildcard path matching and splat</a>
    <li class='indexItem indexItem2'><a href='#Before_hooks_-_processed_before_a_request'>Before hooks - processed before a request</a>
    <li class='indexItem indexItem2'><a href='#Default_route'>Default route</a>
    <li class='indexItem indexItem2'><a href='#Using_the_auto_page_feature_for_automatic_route_creation'>Using the auto_page feature for automatic route creation</a>
    <li class='indexItem indexItem2'><a href='#Why_should_I_use_the_Ajax_plugin'>Why should I use the Ajax plugin</a>
    <li class='indexItem indexItem2'><a href='#Using_the_prefix_feature_to_split_your_application'>Using the prefix feature to split your application</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#MUSCLE_MEMORY%3A_STORING_DATA'>MUSCLE MEMORY: STORING DATA</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Handling_sessions'>Handling sessions</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Storing_data_in_the_session'>Storing data in the session</a>
      <li class='indexItem indexItem3'><a href='#Retrieving_data_from_the_session'>Retrieving data from the session</a>
      <li class='indexItem indexItem3'><a href='#Controlling_where_sessions_are_stored'>Controlling where sessions are stored</a>
      <li class='indexItem indexItem3'><a href='#Destroying_a_session'>Destroying a session</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Sessions_and_logging_in'>Sessions and logging in</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Retrieve_complete_hash_stored_in_session'>Retrieve complete hash stored in session</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#APPEARANCE'>APPEARANCE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Using_templates_-_views_and_layouts'>Using templates - views and layouts</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Views'>Views</a>
      <li class='indexItem indexItem3'><a href='#Layouts'>Layouts</a>
      <li class='indexItem indexItem3'><a href='#template_and_unicode'>template and unicode</a>
      <li class='indexItem indexItem3'><a href='#TT%27s_WRAPPER_directive_in_Dancer_(META_variables%2C_SETs)'>TT&#39;s WRAPPER directive in Dancer (META variables, SETs)</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#SETTING_THE_STAGE%3A_CONFIGURATION_AND_LOGGING'>SETTING THE STAGE: CONFIGURATION AND LOGGING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Configuration_and_environments'>Configuration and environments</a>
    <li class='indexItem indexItem2'><a href='#Accessing_configuration_information_from_your_app'>Accessing configuration information from your app</a>
    <li class='indexItem indexItem2'><a href='#Accessing_configuration_information_from_a_separate_script'>Accessing configuration information from a separate script</a>
    <li class='indexItem indexItem2'><a href='#Logging'>Logging</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Configuring_logging'>Configuring logging</a>
      <li class='indexItem indexItem3'><a href='#Logging_your_own_messages'>Logging your own messages</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#RESTING'>RESTING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Writing_a_REST_application'>Writing a REST application</a>
    <li class='indexItem indexItem2'><a href='#Deploying_your_Dancer_applications'>Deploying your Dancer applications</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DANCER_ON_THE_STAGE%3A_DEPLOYMENT'>DANCER ON THE STAGE: DEPLOYMENT</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Plack_middlewares'>Plack middlewares</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Generic_middlewares'>Generic middlewares</a>
      <li class='indexItem indexItem3'><a href='#Path-based_middlewares'>Path-based middlewares</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Dancer::Cookbook - a quick-start guide to the Dancer web framework</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>A quick-start guide with examples to get you up and running with the Dancer web framework.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BEGINNER&#39;S_DANCE"
>BEGINNER&#39;S DANCE</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Your_first_Dancer_web_app"
>Your first Dancer web app</a></h2>

<p>Dancer has been designed to be easy to work with - it&#39;s trivial to write a simple web app,
but still has the power to work with larger projects.
To start with,
let&#39;s make an incredibly simple &#34;Hello World&#34; example:</p>

<pre>    #!/usr/bin/perl

    use Dancer;

    get &#39;/hello/:name&#39; =&#62; sub {
        return &#34;Why, hello there &#34; . params-&#62;{name};
    };

    dance;</pre>

<p>Yes - the above is a fully-functioning web app; running that script will launch a webserver listening on the default port (3000); now you can make a request</p>

<pre>    $ curl http://localhost:3000/hello/Bob
    Why, hello there Bob</pre>

<p>(or the name of the machine you ran it on, if it&#39;s not your local system), and it will say hello. The <code>:name</code> part is a named parameter within the route specification, whose value is made available through <code>params</code> - more on that later.</p>

<p>Note that you don&#39;t need to use the <code>strict</code> and <code>warnings</code> pragma, they are already loaded by Dancer. (If you don&#39;t want the <code>warnings</code> pragma (which can lead to undesired warnings about use of undef values, for example), then set the <a href="../../Dancer/Config.html#import_warnings" class="podlinkpod"
>import_warnings</a> setting to a false value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Starting_a_Dancer_project"
>Starting a Dancer project</a></h2>

<p>The first simple example is fine for trivial projects, but for anything more complex, you&#39;ll want a more maintainable solution - enter the <code>dancer</code> helper script, which will build the framework of your application with a single command:</p>

<pre>    $ dancer -a mywebapp
    + mywebapp
    + mywebapp/config.yml
    + mywebapp/environments
    + mywebapp/environments/development.yml
    + mywebapp/environments/production.yml
    + mywebapp/views
    + mywebapp/views/index.tt
    + mywebapp/views/layouts
    + mywebapp/views/layouts/main.tt
    + mywebapp/mywebapp.pl
    + mywebapp/lib
    + mywebapp/lib/mywebapp.pm
    + mywebapp/public
    + mywebapp/public/css
    + mywebapp/public/css/style.css
    + mywebapp/public/css/error.css
    + mywebapp/public/images
    + mywebapp/public/404.html
    + mywebapp/public/dispatch.fcgi
    + mywebapp/public/dispatch.cgi
    + mywebapp/public/500.html
    + mywebapp/Makefile.PL
    + mywebapp/t
    + mywebapp/t/002_index_route.t
    + mywebapp/t/001_base.t</pre>

<p>As you can see, it creates a directory named after the name of the app, along with a configuration file, a views directory (where your templates and layouts will live), an environments directory (where environment-specific settings live), a module containing the actual guts of your application, a script to start it - or to run your web app via Plack/PSGI - more on that later.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DANCE_ROUTINES:_ROUTES"
>DANCE ROUTINES: ROUTES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Declaring_routes"
>Declaring routes</a></h2>

<p>To control what happens when a web request is received by your webapp, you&#39;ll need to declare <code>routes</code>. A route declaration indicates which HTTP method(s) it is valid for, the path it matches (e.g. /foo/bar), and a coderef to execute, which returns the response.</p>

<pre>    get &#39;/hello/:name&#39; =&#62; sub {
        return &#34;Hi there &#34; . params-&#62;{name};
    };</pre>

<p>The above route specifies that, for GET requests to &#39;/hello/...&#39;, the code block provided should be executed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Handling_multiple_HTTP_request_methods"
>Handling multiple HTTP request methods</a></h2>

<p>Routes can use <code>any</code> to match all, or a specified list of HTTP methods.</p>

<p>The following will match any HTTP request to the path /myaction:</p>

<pre>    any &#39;/myaction&#39; =&#62; sub {
        # code
    }</pre>

<p>The following will match GET or POST requests to /myaction:</p>

<pre>    any [&#39;get&#39;, &#39;post&#39;] =&#62; &#39;/myaction&#39; =&#62; sub {
        # code
    };</pre>

<p>For convenience, any route which matches GET requests will also match HEAD requests.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Retrieving_request_parameters"
>Retrieving request parameters</a></h2>

<p>The <a href="../../Dancer.html#params" class="podlinkpod"
>params</a> keyword returns a hashref of request parameters; these will be parameters supplied on the query string, within the path itself (with named placeholders), and, for HTTP POST requests, the content of the POST body.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Named_parameters_in_route_path_declarations"
>Named parameters in route path declarations</a></h2>

<p>As seen above, you can use <code>:somename</code> in a route&#39;s path to capture part of the path; this will become available by calling <a href="../../Dancer.html#params" class="podlinkpod"
>params</a>.</p>

<p>So, for a web app where you want to display information on a company, you might use something like:</p>

<pre>    get &#39;/company/view/:companyid&#39; =&#62; sub {
        my $company_id = params-&#62;{companyid};
        # Look up the company and return appropriate page
    };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Wildcard_path_matching_and_splat"
>Wildcard path matching and splat</a></h2>

<p>You can also declare wildcards in a path, and retrieve the values they matched with the <a href="../../Dancer.html#splat" class="podlinkpod"
>splat</a> keyword:</p>

<pre>    get &#39;/*/*&#39; =&#62; sub {
        my ($action, $id) = splat;
        if (my $action eq &#39;view&#39;) {
            return display_item($id);
        } elsif ($action eq &#39;delete&#39;) {
            return delete_item($id);
        } else {
            status &#39;not_found&#39;;
            return &#34;What?&#34;;
        }
    };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Before_hooks_-_processed_before_a_request"
>Before hooks - processed before a request</a></h2>

<p>A before <a href="../../Dancer.html#hook" class="podlinkpod"
>hook</a> declares code which should be handled before a request is passed to the appropriate route.</p>

<pre>    hook &#39;before&#39; =&#62; sub {
        var note =&#62; &#39;Hi there&#39;;
        request-&#62;path(&#39;/foo/oversee&#39;)
    };

    get &#39;/foo/*&#39; =&#62; sub {
        my ($match) = splat; # &#39;oversee&#39;;
        vars-&#62;{note}; # &#39;Hi there&#39;
    };</pre>

<p>The above declares a before hook which uses <code>var</code> to set a variable which will later be available within the route handler, then amends the path of the request to <code>/foo/oversee</code>; this means that, whatever path was requested, it will be treated as though the path requested was <code>/foo/oversee</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Default_route"
>Default route</a></h2>

<p>In case you want to avoid a <i>404 error</i>, or handle multiple routes in the same way and you don&#39;t feel like configuring all of them, you can set up a default route handler.</p>

<p>The default route handler will handle any request that doesn&#39;t get served by any other route.</p>

<p>All you need to do is set up the following route as the <b>last</b> route:</p>

<pre>    any qr{.*} =&#62; sub {
        status &#39;not_found&#39;;
        template &#39;special_404&#39;, { path =&#62; request-&#62;path };
    };</pre>

<p>Then you can set up the template as such:</p>

<pre>    You tried to reach &#60;% path %&#62;, but it is unavailable at the moment.

    Please try again or contact us at our email at &#60;...&#62;.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_the_auto_page_feature_for_automatic_route_creation"
>Using the auto_page feature for automatic route creation</a></h2>

<p>For simple &#34;static&#34; pages, you can simply enable the <code>auto_page</code> config setting; this means that you need not declare a route handler for those pages; if a request is for <code>/foo/bar</code>, Dancer will check for a matching view (e.g. <code>/foo/bar.tt</code> and render it with the default layout etc if found. For full details, see the documentation for the <a href="../../Dancer/Config.html#auto_page" class="podlinkpod"
>auto_page setting</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Why_should_I_use_the_Ajax_plugin"
>Why should I use the Ajax plugin</a></h2>

<p>As an Ajax query is just a HTTP query, it&#39;s similar to a GET or POST route. You may ask yourself why you may want to use the <code>ajax</code> keyword (from the <a href="../../Dancer/Plugin/Ajax.html" class="podlinkpod"
>Dancer::Plugin::Ajax</a> plugin) instead of a simple <code>get</code>.</p>

<p>Let&#39;s say you have a path like &#39;/user/:user&#39; in your application. You may want to be able to serve this page, with a layout and HTML content. But you may also want to be able to call this same url from a javascript query using Ajax.</p>

<p>So, instead of having the following code:</p>

<pre>    get &#39;/user/:user&#39; =&#62; sub {
         if (request-&#62;is_ajax) {
             # create xml, set headers to text/xml, blablabla
              header(&#39;Content-Type&#39; =&#62; &#39;text/xml&#39;);
              header(&#39;Cache-Control&#39; =&#62;  &#39;no-store, no-cache, must-revalidate&#39;);
              to_xml({...})
         }else{
             template users, {....}
         }
    };</pre>

<p>you can have</p>

<pre>    get &#39;/user/:user&#39; =&#62; sub {
        template users, {...}
    }</pre>

<p>and</p>

<pre>    ajax &#39;/user/:user&#39; =&#62; sub {
         to_xml({...}, RootName =&#62; undef);
    }</pre>

<p>Because it&#39;s an ajax query, you know you need to return a xml content, so the content type of the response is set for you.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_the_prefix_feature_to_split_your_application"
>Using the prefix feature to split your application</a></h2>

<p>For better maintainability, you may want to separate some of your application components to different packages. Let&#39;s say we have a simple web app with an admin section, and want to maintain this in a different package:</p>

<pre>    package myapp;
    use Dancer &#39;:syntax&#39;;
    use myapp::admin;

    prefix undef;

    get &#39;/&#39; =&#62; sub {...};

    1;

    package myapp::admin;
    use Dancer &#39;:syntax&#39;;

    prefix &#39;/admin&#39;;

    get &#39;/&#39; =&#62; sub {...};

    1;</pre>

<p>The following routes will be generated for us:</p>

<pre>    - get /
    - get /admin/
    - head /
    - head /admin/</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MUSCLE_MEMORY:_STORING_DATA"
>MUSCLE MEMORY: STORING DATA</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Handling_sessions"
>Handling sessions</a></h2>

<p>It&#39;s common to want to use sessions to give your web applications state; for instance, allowing a user to log in, creating a session, and checking that session on subsequent requests.</p>

<p>To make use of sessions, you must first enable the session engine - pick the session engine you want to use, then declare it in your config file: config file, add:</p>

<pre>    session: Simple</pre>

<p>The <a href="../../Dancer/Session/Simple.html" class="podlinkpod"
>Dancer::Session::Simple</a> backend implements very simple in-memory session storage. This will be fast and useful for testing, but sessions do not persist between restarts of your app.</p>

<p>You can also use the <a href="../../Dancer/Session/YAML.html" class="podlinkpod"
>Dancer::Session::YAML</a> backend included with Dancer, which stores session data on disc in YAML files (since YAML is a nice human-readable format, it makes inspecting the contents of sessions a breeze):</p>

<pre>    session: YAML</pre>

<p>Or, to enable session support from within your code,</p>

<pre>    set session =&#62; &#39;YAML&#39;;</pre>

<p>(Controlling settings is best done from your config file, though). &#39;YAML&#39; in the example is the session backend to use; this is shorthand for <a href="../../Dancer/Session/YAML.html" class="podlinkpod"
>Dancer::Session::YAML</a>. There are other session backends you may wish to use, for instance <a href="../../Dancer/Session/Memcache.html" class="podlinkpod"
>Dancer::Session::Memcache</a>, but the YAML backend is a simple and easy to use example which stores session data in a YAML file in sessions).</p>

<p>You can then use the <a href="../../Dancer.html#session" class="podlinkpod"
>session</a> keyword to manipulate the session:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Storing_data_in_the_session"
>Storing data in the session</a></h3>

<p>Storing data in the session is as easy as:</p>

<pre>    session varname =&#62; &#39;value&#39;;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Retrieving_data_from_the_session"
>Retrieving data from the session</a></h3>

<p>Retrieving data from the session is as easy as:</p>

<pre>    session(&#39;varname&#39;)</pre>

<p>Or, alternatively,</p>

<pre>    session-&#62;{varname}</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Controlling_where_sessions_are_stored"
>Controlling where sessions are stored</a></h3>

<p>For disc-based session back ends like <a href="../../Dancer/Session/YAML.html" class="podlinkpod"
>Dancer::Session::YAML</a>, <a href="../../Dancer/Session/Storable.html" class="podlinkpod"
>Dancer::Session::Storable</a> etc, session files are written to the session dir specified by the <code>session_dir</code> setting, which defaults to <code>appdir/sessions</code> if not specifically set.</p>

<p>If you need to control where session files are created, you can do so quickly and easily within your config file, for example:</p>

<pre>    session_dir: /tmp/dancer-sessions</pre>

<p>If the directory you specify does not exist, Dancer will attempt to create it for you.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Destroying_a_session"
>Destroying a session</a></h3>

<p>When you&#39;re done with your session, you can destroy it:</p>

<pre>    session-&#62;destroy</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Sessions_and_logging_in"
>Sessions and logging in</a></h2>

<p>A common requirement is to check the user is logged in, and, if not, require them to log in before continuing.</p>

<p>This can easily be handled with a before <a href="../../Dancer.html#hook" class="podlinkpod"
>hook</a> to check their session:</p>

<pre>    hook &#39;before&#39; =&#62; sub {
        if (! session(&#39;user&#39;) &#38;&#38; request-&#62;path_info !~ m{^/login}) {
            var requested_path =&#62; request-&#62;path_info;
            request-&#62;path_info(&#39;/login&#39;);
        }
    };

    get &#39;/login&#39; =&#62; sub {
        # Display a login page; the original URL they requested is available as
        # vars-&#62;{requested_path}, so could be put in a hidden field in the form
        template &#39;login&#39;, { path =&#62; vars-&#62;{requested_path} };
    };

    post &#39;/login&#39; =&#62; sub {
        # Validate the username and password they supplied
        if (params-&#62;{user} eq &#39;bob&#39; &#38;&#38; params-&#62;{pass} eq &#39;letmein&#39;) {
            session user =&#62; params-&#62;{user};
            redirect params-&#62;{path} || &#39;/&#39;;
        } else {
            redirect &#39;/login?failed=1&#39;;
        }
    };</pre>

<p>In your login page template, you&#39;ll want a text field named user, a password field named pass, and a hidden field named path, which will be populated with the path originally requested, so that it&#39;s sent back in the POST submission, and can be used by the post route to redirect onwards to the page originally requested once you&#39;re logged in.</p>

<p>Of course, you&#39;ll probably want to validate your users against a database table, or maybe via IMAP/LDAP/SSH/POP3/local system accounts via PAM etc. <a href="../../Authen/Simple.html" class="podlinkpod"
>Authen::Simple</a> is probably a good starting point here!</p>

<p>A simple working example of handling authentication against a database table yourself (using <a href="../../Dancer/Plugin/Database.html" class="podlinkpod"
>Dancer::Plugin::Database</a> which provides the <code>database</code> keyword, and <a href="../../Crypt/SaltedHash.html" class="podlinkpod"
>Crypt::SaltedHash</a> to handle salted hashed passwords (well, you wouldn&#39;t store your users passwords in the clear, would you?)) follows:</p>

<pre>    post &#39;/login&#39; =&#62; sub {
        my $user = database-&#62;quick_select(&#39;users&#39;, 
            { username =&#62; params-&#62;{user} }
        );
        if (!$user) {
            warning &#34;Failed login for unrecognised user &#34; . params-&#62;{user};
            redirect &#39;/login?failed=1&#39;;
        } else {
            if (Crypt::SaltedHash-&#62;validate($user-&#62;{password}, params-&#62;{pass}))
            {
                debug &#34;Password correct&#34;;
                # Logged in successfully
                session user =&#62; $user;
                redirect params-&#62;{path} || &#39;/&#39;;
            } else {
                debug(&#34;Login failed - password incorrect for &#34; . params-&#62;{user});
                redirect &#39;/login?failed=1&#39;;
            }
        }
    };</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Retrieve_complete_hash_stored_in_session"
>Retrieve complete hash stored in session</a></h3>

<p>Get complete hash stored in session:</p>

<pre>    my $hash = session;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="APPEARANCE"
>APPEARANCE</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_templates_-_views_and_layouts"
>Using templates - views and layouts</a></h2>

<p>Returning plain content is all well and good for examples or trivial apps, but soon you&#39;ll want to use templates to maintain separation between your code and your content. Dancer makes this easy.</p>

<p>Your route handlers can use the <a href="../../Dancer.html#template" class="podlinkpod"
>template</a> keyword to render templates.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Views"
>Views</a></h3>

<p>It&#39;s possible to render the action&#39;s content with a template, this is called a view. The `appdir/views&#39; directory is the place where views are located.</p>

<p>You can change this location by changing the setting &#39;views&#39;.</p>

<p>By default, the internal template engine <a href="../../Dancer/Template/Simple.html" class="podlinkpod"
>Dancer::Template::Simple</a> is used, but you may want to upgrade to Template::Toolkit. If you do so, you have to enable this engine in your settings as explained in <a href="../../Dancer/Template/TemplateToolkit.html" class="podlinkpod"
>Dancer::Template::TemplateToolkit</a>. If you do so, you&#39;ll also have to import the <a href="../../Template.html" class="podlinkpod"
>Template</a> module in your application code.</p>

<p>Note that, by default, Dancer configures the Template::Toolkit engine to use <code>&#60;% %</code>&#62; brackets instead of its default <code>[% %]</code> brackets. You can change this by using the following in your config file:</p>

<pre>    template: template_toolkit

    engines:
        template_toolkit:
            start_tag: &#39;[%&#39;
            stop_tag: &#39;%]&#39;</pre>

<p>All views must have a &#39;.tt&#39; extension. This may change in the future.</p>

<p>In order to render a view, just call the <code>template|Dancer/template</code> keyword at the end of the action by giving the view name and the HASHREF of tokens to interpolate in the view (note that for convenience, the request, session, params and vars are automatically accessible in the view, named <code>request</code>, <code>session</code>, <code>params</code> and <code>vars</code>) - for example:</p>

<pre>    hook &#39;before&#39; =&#62; sub { var time =&#62; scalar(localtime) };

    get &#39;/hello/:name&#39; =&#62; sub {
        my $name = params-&#62;{name};
        template &#39;hello.tt&#39;, { name =&#62; $name };
    };</pre>

<p>The template &#39;hello.tt&#39; could contain, for example:</p>

<pre>    &#60;p&#62;Hi there, &#60;% name %&#62;!&#60;/p&#62;
    &#60;p&#62;You&#39;re using &#60;% request.user_agent %&#62;&#60;/p&#62;
    &#60;% IF session.username %&#62;
        &#60;p&#62;You&#39;re logged in as &#60;% session.username %&#62;
    &#60;% END %&#62;
    It&#39;s currently &#60;% vars.time %&#62;</pre>

<p>For a full list of the tokens automatically added to your template (like <code>session</code>, <code>request</code> and <code>vars</code>, refer to <a href="../../Dancer/Template/Abstract.html" class="podlinkpod"
>Dancer::Template::Abstract</a>).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Layouts"
>Layouts</a></h3>

<p>A layout is a special view, located in the &#39;layouts&#39; directory (inside the views directory) which must have a token named &#39;content&#39;. That token marks the place where to render the action view. This lets you define a global layout for your actions, and have each individual view contain only the specific content. This is a good thing to avoid lots of needless duplication of HTML :)</p>

<p>Here is an example of a layout: <code>views/layouts/main.tt</code> :</p>

<pre>    &#60;html&#62;
        &#60;head&#62;...&#60;/head&#62;
        &#60;body&#62;
        &#60;div id=&#34;header&#34;&#62;
        ...
        &#60;/div&#62;

        &#60;div id=&#34;content&#34;&#62;
        &#60;% content %&#62;
        &#60;/div&#62;

        &#60;/body&#62;
    &#60;/html&#62;</pre>

<p>You can tell your app which layout to use with <code>layout: name</code> in the config file, or within your code:</p>

<pre>    set layout =&#62; &#39;main&#39;;</pre>

<p>You can control which layout to use (or whether to use a layout at all) for a specific request without altering the layout setting by passing an options hashref as the third param to the template keyword:</p>

<pre>    template &#39;index.tt&#39;, {}, { layout =&#62; undef };</pre>

<p>If your application is not mounted under root (<b>/</b>), you can use a before_template_render hook instead of hardcoding the path to your application for your css, images and javascript:</p>

<pre>    hook &#39;before_template_render&#39; =&#62; sub {
        my $tokens = shift;
        $tokens-&#62;{uri_base} = request-&#62;base-&#62;path;
    };</pre>

<p>THen in your layout, modify your css inclusion as follows:</p>

<pre>    &#60;link rel=&#34;stylesheet&#34; href=&#34;&#60;% uri_base %&#62;/css/style.css&#34; /&#62;</pre>

<p>From now on, you can mount your application wherever you want, without any further modification of the css inclusion</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="template_and_unicode"
>template and unicode</a></h3>

<p>If you use <a href="../../Plack.html" class="podlinkpod"
>Plack</a> and have some unicode problem with your Dancer application, don&#39;t forget to check if you have set your template engine to use unicode, and set the default charset to UTF-8. So, if you are using template toolkit, your config.yml will look like this:</p>

<pre>    charset: UTF-8
    engines:
      template_toolkit:
        ENCODING: utf8</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="TT&#39;s_WRAPPER_directive_in_Dancer_(META_variables,_SETs)"
>TT&#39;s WRAPPER directive in Dancer (META variables, SETs)</a></h3>

<p>Dancer already provides a WRAPPER-like ability, which we call a &#34;layout&#34;. The reason we do not use TT&#39;s WRAPPER (which also makes it incompatible with it) is because not all template systems support it. Actually, most don&#39;t.</p>

<p>However, you might want to use it, and be able to define META variables and regular <a href="../../Template/Toolkit.html" class="podlinkpod"
>Template::Toolkit</a> variables.</p>

<p>These few steps will get you there:</p>

<ul>
<li>Disable the layout in Dancer
<p>You can do this by simply commenting (or removing) the <code>layout</code> configuration in the <em>config.yml</em> file.</p>
</li>

<li>Use Template Toolkit template engine
<p>Change the configuration of the template to Template Toolkit:</p>

<pre>    # in config.yml
    template: &#34;template_toolkit&#34;</pre>
</li>

<li>Tell the Template Toolkit engine who&#39;s your wrapper
<pre>    # in config.yml
    # ...
    engines:
        template_toolkit:
            WRAPPER: layouts/main.tt</pre>
</li>
</ul>

<p>Done! Everything will work fine out of the box, including variables and META variables.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SETTING_THE_STAGE:_CONFIGURATION_AND_LOGGING"
>SETTING THE STAGE: CONFIGURATION AND LOGGING</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Configuration_and_environments"
>Configuration and environments</a></h2>

<p>Configuring a Dancer application can be done in many ways. The easiest one (and maybe the the dirtiest) is to put all your settings statements at the top of your script, before calling the dance() method.</p>

<p>Other ways are possible, you can define all your settings in the file `appdir/config.yml&#39;. For this, you must have installed the YAML module, and of course, write the config file in YAML.</p>

<p>That&#39;s better than the first option, but it&#39;s still not perfect as you can&#39;t switch easily from an environment to another without rewriting the config.yml file.</p>

<p>The better way is to have one config.yml file with default global settings, like the following:</p>

<pre>    # appdir/config.yml
    logger: &#39;file&#39;
    layout: &#39;main&#39;</pre>

<p>And then write as many environment files as you like in <code>appdir/environments</code>. That way, the appropriate environment config file will be loaded according to the running environment (if none is specified, it will be &#39;development&#39;).</p>

<p>Note that you can change the running environment using the <code>--environment</code> commandline switch.</p>

<p>Typically, you&#39;ll want to set the following values in a development config file:</p>

<pre>    # appdir/environments/development.yml
    log: &#39;debug&#39;
    startup_info: 1
    show_errors:  1</pre>

<p>And in a production one:</p>

<pre>    # appdir/environments/production.yml
    log: &#39;warning&#39;
    startup_info: 0
    show_errors:  0</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_configuration_information_from_your_app"
>Accessing configuration information from your app</a></h2>

<p>A Dancer application can use the &#39;config&#39; keyword to easily access the settings within its config file, for instance:</p>

<pre>    get &#39;/appname&#39; =&#62; sub {
        return &#34;This is &#34; . config-&#62;{appname};
    };</pre>

<p>This makes keeping your application&#39;s settings all in one place simple and easy - you shouldn&#39;t need to worry about implementing all that yourself :)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_configuration_information_from_a_separate_script"
>Accessing configuration information from a separate script</a></h2>

<p>You may well want to access your webapp&#39;s configuration from outside your webapp. You could, of course, use the YAML module of your choice and load your webapps&#39;s config.yml, but chances are that this is not convenient.</p>

<p>Use Dancer instead. Without any ado, magic or too big jumps, you can use the values from config.yml and some additional default values:</p>

<pre>        # bin/script1.pl
        use Dancer &#39;:script&#39;;
        print &#34;template:&#34;.config-&#62;{template}.&#34;\n&#34;; #simple
        print &#34;log:&#34;.config-&#62;{log}.&#34;\n&#34;; #undef</pre>

<p>Note that config-&#62;{log} should result undef error on a default scaffold since you did not load the environment and in the default scaffold log is defined in the environment and not in config.yml. Hence undef.</p>

<p>If you want to load an environment you need to tell Dancer where to look for it. One way to do so, is to tell Dancer where the webapp lives. From there Dancer deducts where the config.yml file is (typically $webapp/config.yml).</p>

<pre>        # bin/script2.pl
        use FindBin;
        use Cwd qw/realpath/;
        use Dancer &#39;:script&#39;;

        #tell the Dancer where the app lives
        my $appdir=realpath( &#34;$FindBin::Bin/..&#34;);

        Dancer::Config::setting(&#39;appdir&#39;,$appdir);
        Dancer::Config::load();

        #getter
        print &#34;environment:&#34;.config-&#62;{environment}.&#34;\n&#34;; #development
        print &#34;log:&#34;.config-&#62;{log}.&#34;\n&#34;; #value from development environment</pre>

<p>By default Dancer loads development environment (typically $webapp/environment/development.yml). In contrast to the example before, you do have a value from the development environment (environment/development.yml) now. Also note that in the above example Cwd and FindBin are used. They are likely to be already loaded by Dancer anyways, so it&#39;s not a big overhead. You could just as well hand over a simple path for the app if you like that better, e.g.:</p>

<pre>        Dancer::Config::setting(&#39;appdir&#39;,&#39;/path/to/app/dir&#39;);</pre>

<p>If you want to load an environment other than the default, try this:</p>

<pre>        # bin/script2.pl
        use Dancer &#39;:script&#39;;

        #tell the Dancer where the app lives
        Dancer::Config::setting(&#39;appdir&#39;,&#39;/path/to/app/dir&#39;);

        #which environment to load
        config-&#62;{environment}=&#39;production&#39;;

        Dancer::Config::load();

        #getter
        print &#34;log:&#34;.config-&#62;{log}.&#34;\n&#34;; #has value from production environment</pre>

<p>By the way, you not only get values, you can also set values straightforward like we do above with config-&#62;{environment}=&#39;production&#39;. Of course, this value does not get written in any file; it only lives in memory and your webapp doesn&#39;t have access to it, but you can use it inside your script.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Logging"
>Logging</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Configuring_logging"
>Configuring logging</a></h3>

<p>It&#39;s possible to log messages generated by the application and by Dancer itself.</p>

<p>To start logging, select the logging engine you wish to use with the <code>logger</code> setting; Dancer includes built-in log engines named <code>file</code> and <code>console</code>, which log to a logfile and to the console respectively.</p>

<p>To enable logging to a file, add the following to your config.yml:</p>

<pre>    logger: &#39;file&#39;</pre>

<p>Then you can choose which kind of messages you want to actually log:</p>

<pre>    log: &#39;core&#39;      # will log all messages, including messages from
                     # Dancer itself
    log: &#39;debug&#39;     # will log debug, info, warning and error messages
    log: &#39;info&#39;      # will log info, warning and error messages
    log: &#39;warning&#39;   # will log warning and error messages
    log: &#39;error&#39;     # will log error messages</pre>

<p>If you&#39;re using the <code>file</code> logging engine, a directory <code>appdir/logs</code> will be created and will host one logfile per environment. The log message contains the time it was written, the PID of the current process, the message and the caller information (file and line).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Logging_your_own_messages"
>Logging your own messages</a></h3>

<p>Just call <a href="../../Dancer.html#debug" class="podlinkpod"
>debug</a>, <a href="../../Dancer.html#warning" class="podlinkpod"
>warning</a>, <a href="../../Dancer.html#error" class="podlinkpod"
>error</a> or <a href="../../Dancer.html#info" class="podlinkpod"
>info</a> with your message:</p>

<pre>    debug &#34;This is a debug message from my app.&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RESTING"
>RESTING</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Writing_a_REST_application"
>Writing a REST application</a></h2>

<p>With Dancer, it&#39;s easy to write REST applications. Dancer provides helpers to serialize and deserialize for the following data formats:</p>

<dl>
<dt><a name="JSON"
>JSON</a></dt>

<dd>
<dt><a name="YAML"
>YAML</a></dt>

<dd>
<dt><a name="XML"
>XML</a></dt>

<dd>
<dt><a name="Data::Dumper"
>Data::Dumper</a></dt>
</dl>

<p>To activate this feature, you only have to set the <code>serializer</code> setting to the format you require, for instance in your config.yml:</p>

<pre>   serializer: JSON</pre>

<p>Or right in your code:</p>

<pre>   set serializer =&#62; &#39;JSON&#39;;</pre>

<p>From now, all hash ref or array ref returned by a route will be serialized to the format you chose, and all data received from <b>POST</b> or <b>PUT</b> requests will be automatically deserialized.</p>

<pre>    get &#39;/hello/:name&#39; =&#62; sub {
        # this structure will be returned to the client as
        # {&#34;name&#34;:&#34;$name&#34;}
        return {name =&#62; params-&#62;{name}};
    };</pre>

<p>It&#39;s possible to let the client choose which serializer he want to use. For this, use the <b>mutable</b> serializer, and an appropriate serializer will be chosen from the <b>Content-Type</b> header.</p>

<p>It&#39;s also possible to return a custom error, using the <a href="../../Dancer.html#send_error" class="podlinkpod"
>send_error</a> keyword.. When you don&#39;t use a serializer, the <code>send_error</code> function will take a string as first parameter (the message), and an optional HTTP code. When using a serializer, the message can be a string, an arrayref or a hashref:</p>

<pre>    get &#39;/hello/:name&#39; =&#62; sub {
        if (...) {
           send_error(&#34;you can&#39;t do that&#34;);
           # or
           send_error({reason =&#62; &#39;access denied&#39;, message =&#62; &#34;no&#34;});
        }
    };</pre>

<p>The content of the error will be serialized using the appropriate serializer.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Deploying_your_Dancer_applications"
>Deploying your Dancer applications</a></h2>

<p>For examples on deploying your Dancer applications (including standalone, behind proxy/load-balancing software, and using common web servers including Apache to run via CGI/FastCGI etc, see <a href="../../Dancer/Deployment.html" class="podlinkpod"
>Dancer::Deployment</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DANCER_ON_THE_STAGE:_DEPLOYMENT"
>DANCER ON THE STAGE: DEPLOYMENT</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Plack_middlewares"
>Plack middlewares</a></h2>

<p>If you deploy with Plack and use some Plack middlewares, you can enable them directly from Dancer&#39;s configuration files.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Generic_middlewares"
>Generic middlewares</a></h3>

<p>To enable middlewares in Dancer, you just have to set the plack_middlewares setting like the following:</p>

<pre>    set plack_middlewares =&#62; [
        [ &#39;SomeMiddleware&#39; =&#62; [ qw(some options for somemiddleware) ]],
    ];</pre>

<p>For instance, if you want to enable <a href="../../Plack/Middleware/Debug.html" class="podlinkpod"
>Plack::Middleware::Debug</a> in your Dancer application, all you have to do is to set <code>plack_middlewares</code> like that:</p>

<pre>    set plack_middlewares =&#62; [
        [ &#39;Debug&#39; =&#62; [ &#39;panels&#39; =&#62; [qw(DBITrace Memory Timer)] ] ],
    ];</pre>

<p>Of course, you can also put this configuration into your config.yml file, or even in your environment configuration files:</p>

<pre>    # environments/development.yml
    ...
    plack_middlewares:
      -
        - Debug          # first element of the array is the name of the middleware
        -
            - panels         # following elements are the configuration ofthe middleware
            -
              - DBITrace
              - Memory
              - Timer</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Path-based_middlewares"
>Path-based middlewares</a></h3>

<p>If you want to setup a middleware for a specific path, you can do that using <code>plack_middlewares_map</code>. You&#39;ll need <a href="../../Plack/App/URLMap.html" class="podlinkpod"
>Plack::App::URLMap</a> to do that.</p>

<pre>    plack_middlewares_map:
        &#39;/&#39;:      [&#39;Debug&#39;]
        &#39;/timer&#39;: [&#39;Timer&#39;],</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Dancer contributors - see AUTHORS file.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
