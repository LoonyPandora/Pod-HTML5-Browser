<html><head><title>Dancer::Test</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.22,
  using Pod::Simple::PullParser v3.22,
  under Perl v5.014001 at Sun Jun 24 19:07:14 2012 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSYS'>SYNOPSYS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#route_exists(%5B%24method%2C_%24path%5D%2C_%24test_name)'>route_exists([$method, $path], $test_name)</a>
    <li class='indexItem indexItem2'><a href='#route_doesnt_exist(%5B%24method%2C_%24path%5D%2C_%24test_name)'>route_doesnt_exist([$method, $path], $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_exists(%5B%24method%2C_%24path%5D%2C_%24test_name)'>response_exists([$method, $path], $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_doesnt_exist(%5B%24method%2C_%24path%5D%2C_%24test_name)'>response_doesnt_exist([$method, $path], $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_status_is(%5B%24method%2C_%24path%5D%2C_%24status%2C_%24test_name)'>response_status_is([$method, $path], $status, $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_status_isnt(%5B%24method%2C_%24path%5D%2C_%24status%2C_%24test_name)'>response_status_isnt([$method, $path], $status, $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_content_is(%5B%24method%2C_%24path%5D%2C_%24expected%2C_%24test_name)'>response_content_is([$method, $path], $expected, $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_content_isnt(%5B%24method%2C_%24path%5D%2C_%24not_expected%2C_%24test_name)'>response_content_isnt([$method, $path], $not_expected, $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_content_is_deeply(%5B%24method%2C_%24path%5D%2C_%24expected_struct%2C_%24test_name)'>response_content_is_deeply([$method, $path], $expected_struct, $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_content_like(%5B%24method%2C_%24path%5D%2C_%24regexp%2C_%24test_name)'>response_content_like([$method, $path], $regexp, $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_content_unlike(%5B%24method%2C_%24path%5D%2C_%24regexp%2C_%24test_name)'>response_content_unlike([$method, $path], $regexp, $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_headers_are_deeply(%5B%24method%2C_%24path%5D%2C_%24expected%2C_%24test_name)'>response_headers_are_deeply([$method, $path], $expected, $test_name)</a>
    <li class='indexItem indexItem2'><a href='#response_headers_include(%5B%24method%2C_%24path%5D%2C_%24expected%2C_%24test_name)'>response_headers_include([$method, $path], $expected, $test_name)</a>
    <li class='indexItem indexItem2'><a href='#read_logs'>read_logs</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Dancer::Test - Test helpers to test a Dancer application</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSYS"
>SYNOPSYS</a></h1>

<pre>    use strict;
    use warnings;
    use Test::More tests =&#62; 2;

    use MyWebApp;
    use Dancer::Test;

    response_status_is [GET =&#62; &#39;/&#39;], 200, &#34;GET / is found&#34;;
    response_content_like [GET =&#62; &#39;/&#39;], qr/hello, world/, &#34;content looks good for /&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module provides test helpers for testing Dancer apps.</p>

<p>Be careful, the module loading order in the example above is very important. Make sure to use <code>Dancer::Test</code> <b>after</b> importing the application package otherwise your appdir will be automatically set to <code>lib</code> and your test script won&#39;t be able to find views, conffiles and other application content.</p>

<p>For all test methods, the first argument can be either an array ref of the method and route, or a scalar containing the route (in which case the method is assumed to be <code>GET</code>), or a <a href="../../Dancer/Response.html" class="podlinkpod"
>Dancer::Response</a> object.</p>

<pre>    # all 3 are equivalent
    response_status_is [ GET =&#62; &#39;/&#39; ], 200, &#39;GET / status is ok&#39;;

    response_status_is &#39;/&#39;, 200, &#39;GET / status is ok&#39;;

    my $resp = dancer_response GET =&#62; &#39;/&#39;;
    response_status_is $resp =&#62; 200, &#39;GET / status is ok&#39;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="route_exists([$method,_$path],_$test_name)"
>route_exists([$method, $path], $test_name)</a></h2>

<p>Asserts that the given request matches a route handler in Dancer&#39;s registry.</p>

<pre>    route_exists [GET =&#62; &#39;/&#39;], &#34;GET / is handled&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="route_doesnt_exist([$method,_$path],_$test_name)"
>route_doesnt_exist([$method, $path], $test_name)</a></h2>

<p>Asserts that the given request does not match any route handler in Dancer&#39;s registry.</p>

<pre>    route_doesnt_exist [GET =&#62; &#39;/bogus_path&#39;], &#34;GET /bogus_path is not handled&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_exists([$method,_$path],_$test_name)"
>response_exists([$method, $path], $test_name)</a></h2>

<p>Asserts that a response is found for the given request (note that even though a route for that path might not exist, a response can be found during request processing, because of filters).</p>

<pre>    response_exists [GET =&#62; &#39;/path_that_gets_redirected_to_home&#39;],
        &#34;response found for unknown path&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_doesnt_exist([$method,_$path],_$test_name)"
>response_doesnt_exist([$method, $path], $test_name)</a></h2>

<p>Asserts that no response is found when processing the given request.</p>

<pre>    response_doesnt_exist [GET =&#62; &#39;/unknown_path&#39;],
        &#34;response not found for unknown path&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_status_is([$method,_$path],_$status,_$test_name)"
>response_status_is([$method, $path], $status, $test_name)</a></h2>

<p>Asserts that Dancer&#39;s response for the given request has a status equal to the one given.</p>

<pre>    response_status_is [GET =&#62; &#39;/&#39;], 200, &#34;response for GET / is 200&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_status_isnt([$method,_$path],_$status,_$test_name)"
>response_status_isnt([$method, $path], $status, $test_name)</a></h2>

<p>Asserts that the status of Dancer&#39;s response is not equal to the one given.</p>

<pre>    response_status_isnt [GET =&#62; &#39;/&#39;], 404, &#34;response for GET / is not a 404&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_content_is([$method,_$path],_$expected,_$test_name)"
>response_content_is([$method, $path], $expected, $test_name)</a></h2>

<p>Asserts that the response content is equal to the <code>$expected</code> string.</p>

<pre>    response_content_is [GET =&#62; &#39;/&#39;], &#34;Hello, World&#34;, 
        &#34;got expected response content for GET /&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_content_isnt([$method,_$path],_$not_expected,_$test_name)"
>response_content_isnt([$method, $path], $not_expected, $test_name)</a></h2>

<p>Asserts that the response content is not equal to the <code>$not_expected</code> string.</p>

<pre>    response_content_isnt [GET =&#62; &#39;/&#39;], &#34;Hello, World&#34;, 
        &#34;got expected response content for GET /&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_content_is_deeply([$method,_$path],_$expected_struct,_$test_name)"
>response_content_is_deeply([$method, $path], $expected_struct, $test_name)</a></h2>

<p>Similar to response_content_is(), except that if response content and $expected_struct are references, it does a deep comparison walking each data structure to see if they are equivalent.</p>

<p>If the two structures are different, it will display the place where they start differing.</p>

<pre>    response_content_is_deeply [GET =&#62; &#39;/complex_struct&#39;], 
        { foo =&#62; 42, bar =&#62; 24}, 
        &#34;got expected response structure for GET /complex_struct&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_content_like([$method,_$path],_$regexp,_$test_name)"
>response_content_like([$method, $path], $regexp, $test_name)</a></h2>

<p>Asserts that the response content for the given request matches the regexp given.</p>

<pre>    response_content_like [GET =&#62; &#39;/&#39;], qr/Hello, World/, 
        &#34;response content looks good for GET /&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_content_unlike([$method,_$path],_$regexp,_$test_name)"
>response_content_unlike([$method, $path], $regexp, $test_name)</a></h2>

<p>Asserts that the response content for the given request does not match the regexp given.</p>

<pre>    response_content_unlike [GET =&#62; &#39;/&#39;], qr/Page not found/, 
        &#34;response content looks good for GET /&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_headers_are_deeply([$method,_$path],_$expected,_$test_name)"
>response_headers_are_deeply([$method, $path], $expected, $test_name)</a></h2>

<p>Asserts that the response headers data structure equals the one given.</p>

<pre>    response_headers_are_deeply [GET =&#62; &#39;/&#39;], [ &#39;X-Powered-By&#39; =&#62; &#39;Dancer 1.150&#39; ];</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="response_headers_include([$method,_$path],_$expected,_$test_name)"
>response_headers_include([$method, $path], $expected, $test_name)</a></h2>

<p>Asserts that the response headers data structure includes some of the defined ones.</p>

<pre>    response_headers_include [GET =&#62; &#39;/&#39;], [ &#39;Content-Type&#39; =&#62; &#39;text/plain&#39; ];</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'

>dancer_response($method, $path, { params =&#62; $params, body =&#62; $body, headers =&#62; $headers, files =&#62; [{filename =&#62; &#39;/path/to/file&#39;, name =&#62; &#39;my_file&#39;}] })</a></h2>

<p>Returns a Dancer::Response object for the given request.</p>

<p>Only $method and $path are required.</p>

<p>$params is a hashref, $body is a string and $headers can be an arrayref or a HTTP::Headers object, $files is an arrayref of hashref, containing some files to upload.</p>

<p>A good reason to use this function is for testing POST requests. Since POST requests may not be idempotent, it is necessary to capture the content and status in one shot. Calling the response_status_is and response_content_is functions in succession would make two requests, each of which could alter the state of the application and cause Schrodinger&#39;s cat to die.</p>

<pre>    my $response = dancer_response POST =&#62; &#39;/widgets&#39;;
    is $response-&#62;{status}, 202, &#34;response for POST /widgets is 202&#34;;
    is $response-&#62;{content}, &#34;Widget #1 has been scheduled for creation&#34;,
        &#34;response content looks good for first POST /widgets&#34;;

    $response = dancer_response POST =&#62; &#39;/widgets&#39;;
    is $response-&#62;{status}, 202, &#34;response for POST /widgets is 202&#34;;
    is $response-&#62;{content}, &#34;Widget #2 has been scheduled for creation&#34;,
        &#34;response content looks good for second POST /widgets&#34;;</pre>

<p>It&#39;s possible to test file uploads:</p>

<pre>    post &#39;/upload&#39; =&#62; sub { return upload(&#39;image&#39;)-&#62;content };

    $response = dancer_response(POST =&#62; &#39;/upload&#39;, {files =&#62; [{name =&#62; &#39;image&#39;, filename =&#62; &#39;/path/to/image.jpg&#39;}]});</pre>

<p>In addition, you can supply the file contents as the <code>data</code> key:</p>

<pre>    my $data  = &#39;A test string that will pretend to be file contents.&#39;;
    $response = dancer_response(POST =&#62; &#39;/upload&#39;, {
        files =&#62; [{name =&#62; &#39;test&#39;, filename =&#62; &#34;filename.ext&#34;, data =&#62; $data}]
    });</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="read_logs"
>read_logs</a></h2>

<pre>    my $logs = read_logs;</pre>

<p>Returns an array ref of all log messages issued by the app since the last call to <code>read_logs</code>.</p>

<p>For example:</p>

<pre>    warning &#34;Danger!  Warning!&#34;;
    debug   &#34;I like pie.&#34;;

    is_deeply read_logs, [
        { level =&#62; &#34;warning&#34;, message =&#62; &#34;Danger!  Warning!&#34; },
        { level =&#62; &#34;debug&#34;,   message =&#62; &#34;I like pie.&#34;, }
    ];

    error &#34;Put out the light.&#34;;

    is_deeply read_logs, [
        { level =&#62; &#34;error&#34;, message =&#62; &#34;Put out the light.&#34; },
    ];</pre>

<p>See <a href="../../Dancer/Logger/Capture.html" class="podlinkpod"
>Dancer::Logger::Capture</a> for more details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This module is free software and is distributed under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>This module has been written by Alexis Sukrieh &#60;sukria@sukria.net&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Test/More.html" class="podlinkpod"
>Test::More</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
