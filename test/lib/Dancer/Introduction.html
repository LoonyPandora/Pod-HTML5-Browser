<html><head><title>Dancer::Introduction</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.22,
  using Pod::Simple::PullParser v3.22,
  under Perl v5.014001 at Sun Jun 24 19:07:14 2012 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#INSTALL'>INSTALL</a>
  <li class='indexItem indexItem1'><a href='#SETUP'>SETUP</a>
  <li class='indexItem indexItem1'><a href='#USAGE'>USAGE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#HTTP_METHODS'>HTTP METHODS</a>
    <li class='indexItem indexItem2'><a href='#ROUTE_HANDLERS'>ROUTE HANDLERS</a>
    <li class='indexItem indexItem2'><a href='#NAMED_MATCHING'>NAMED MATCHING</a>
    <li class='indexItem indexItem2'><a href='#WILDCARDS_MATCHING'>WILDCARDS MATCHING</a>
    <li class='indexItem indexItem2'><a href='#REGULAR_EXPRESSION_MATCHING'>REGULAR EXPRESSION MATCHING</a>
    <li class='indexItem indexItem2'><a href='#CONDITIONAL_MATCHING'>CONDITIONAL MATCHING</a>
    <li class='indexItem indexItem2'><a href='#PREFIX'>PREFIX</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ACTION_SKIPPING'>ACTION SKIPPING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#DEFAULT_ERROR_PAGES'>DEFAULT ERROR PAGES</a>
    <li class='indexItem indexItem2'><a href='#EXECUTION_ERRORS'>EXECUTION ERRORS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#HOOKS'>HOOKS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Before_hooks'>Before hooks</a>
    <li class='indexItem indexItem2'><a href='#After_hooks'>After hooks</a>
    <li class='indexItem indexItem2'><a href='#Before_template_hook'>Before template hook</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CONFIGURATION_AND_ENVIRONMENTS'>CONFIGURATION AND ENVIRONMENTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#load'>load</a>
    <li class='indexItem indexItem2'><a href='#Accessing_configuration_data'>Accessing configuration data</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Importing_just_the_syntax'>Importing just the syntax</a>
  <li class='indexItem indexItem1'><a href='#LOGGING'>LOGGING</a>
  <li class='indexItem indexItem1'><a href='#USING_TEMPLATES'>USING TEMPLATES</a>
  <li class='indexItem indexItem1'><a href='#VIEWS'>VIEWS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#LAYOUTS'>LAYOUTS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#STATIC_FILES'>STATIC FILES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#STATIC_DIRECTORY'>STATIC DIRECTORY</a>
    <li class='indexItem indexItem2'><a href='#STATIC_FILE_FROM_A_ROUTE_HANDLER'>STATIC FILE FROM A ROUTE HANDLER</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SETTINGS'>SETTINGS</a>
  <li class='indexItem indexItem1'><a href='#SERIALIZERS'>SERIALIZERS</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLE'>EXAMPLE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Dancer::Introduction - A gentle introduction to Dancer</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Dancer is a free and open source micro web application framework written in Perl.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INSTALL"
>INSTALL</a></h1>

<p>Installation of Dancer is simple:</p>

<pre>    perl -MCPAN -e &#39;install Dancer&#39;</pre>

<p>Thanks to the magic of cpanminus, if you do not have CPAN.pm configured, or just want a quickfire way to get running, the following should work, at least on Unix-like systems:</p>

<pre>    wget -O - http://cpanmin.us | sudo perl - Dancer</pre>

<p>(If you don&#39;t have root access, omit the &#39;sudo&#39;, and cpanminus will install Dancer and prereqs into <code>~/perl5</code>.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SETUP"
>SETUP</a></h1>

<p>Create a web application using the dancer script:</p>

<pre>    dancer -a MyApp</pre>

<p>Run the web application:</p>

<pre>    cd MyApp
    bin/app.pl</pre>

<p>You can read the output of <code>bin/app.pl --help</code> to change any settings such as the port number.</p>

<p>View the web application at:</p>

<pre>    http://localhost:3000</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USAGE"
>USAGE</a></h1>

<p>When Dancer is imported to a script, that script becomes a webapp, and at this point, all the script has to do is declare a list of <b>routes</b>. A route handler is composed by an HTTP method, a path pattern and a code block. <code>strict</code> and <code>warnings</code> pragmas are also imported with Dancer.</p>

<p>The code block given to the route handler has to return a string which will be used as the content to render to the client.</p>

<p>Routes are defined for a given HTTP method. For each method supported, a keyword is exported by the module.</p>

<p>The following is an example of a route definition. The route is defined for the method &#39;get&#39;, so only GET requests will be honoured by that route:</p>

<pre>    get &#39;/hello/:name&#39; =&#62; sub {
        # do something

        return &#34;Hello &#34;.param(&#39;name&#39;);
    };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HTTP_METHODS"
>HTTP METHODS</a></h2>

<p>Here are some of the standard HTTP methods which you can use to define your route handlers.</p>

<dl>
<dt><a 
><b>GET</b> The GET method retrieves information (when defining a route handler for the GET method, Dancer automatically defines a route handler for the HEAD method, in order to honour HEAD requests for each of your GET route handlers). To define a GET action, use the <b>get</b> keyword.</a></dt>

<dd>
<dt><a name="POST_The_POST_method_is_used_to_create_a_resource_on_the_server._To_define_a_POST_action,_use_the_post_keyword."
><b>POST</b> The POST method is used to create a resource on the server. To define a POST action, use the <b>post</b> keyword.</a></dt>

<dd>
<dt><a name="PUT_The_PUT_method_is_used_to_update_an_existing_resource._To_define_a_PUT_action,_use_the_put_keyword."
><b>PUT</b> The PUT method is used to update an existing resource. To define a PUT action, use the <b>put</b> keyword.</a></dt>

<dd>
<dt><a 
><b>DELETE</b> The DELETE method requests that the origin server delete the resource identified by the Request-URI. To define a DELETE action, use the <b>del</b> keyword.</a></dt>
</dl>

<p>To define a route for multiple methods you can also use the special keyword <b>any</b>. This example illustrates how to define a route for both GET and POST methods:</p>

<pre>    any [&#39;get&#39;, &#39;post&#39;] =&#62; &#39;/myaction&#39; =&#62; sub {
        # code
    };</pre>

<p>Or even, a route handler that would match any HTTP methods:</p>

<pre>    any &#39;/myaction&#39; =&#62; sub {
        # code
    };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ROUTE_HANDLERS"
>ROUTE HANDLERS</a></h2>

<p>The route action is the code reference declared. It can access parameters through the `params&#39; keyword, which returns a hashref. This hashref is a merge of the route pattern matches and the request params.</p>

<p>You can have more details about how params are built and how to access them in the <a href="../../Dancer/Request.html" class="podlinkpod"
>Dancer::Request</a> documentation.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="NAMED_MATCHING"
>NAMED MATCHING</a></h2>

<p>A route pattern can contain one or more tokens (a word prefixed with &#39;:&#39;). Each token found in a route pattern is used as a named-pattern match. Any match will be set in the params hashref.</p>

<pre>    get &#39;/hello/:name&#39; =&#62; sub {
        &#34;Hey &#34;.param(&#39;name&#39;).&#34;, welcome here!&#34;;
    };</pre>

<p>Tokens can be optional, for example:</p>

<pre>    get &#39;/hello/:name?&#39; =&#62; sub {
        &#34;Hello there &#34; . (param(&#39;name&#39;) || &#34;whoever you are!&#34;);
    };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="WILDCARDS_MATCHING"
>WILDCARDS MATCHING</a></h2>

<p>A route can contain a wildcard (represented by a &#39;*&#39;). Each wildcard match will be returned in an arrayref, accessible via the `splat&#39; keyword.</p>

<pre>    get &#39;/download/*.*&#39; =&#62; sub {
        my ($file, $ext) = splat;
        # do something with $file.$ext here
    };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="REGULAR_EXPRESSION_MATCHING"
>REGULAR EXPRESSION MATCHING</a></h2>

<p>A route can be defined with a Perl regular expression.</p>

<p>In order to tell Dancer to consider the route as a real regexp, the route must be defined explicitly with <code>qr{}</code>, like the following:</p>

<pre>    get qr{/hello/([\w]+)} =&#62; sub {
        my ($name) = splat;
        return &#34;Hello $name&#34;;
    };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CONDITIONAL_MATCHING"
>CONDITIONAL MATCHING</a></h2>

<p>Routes may include some matching conditions (on the useragent and the hostname at the moment):</p>

<pre>    get &#39;/foo&#39;, {agent =&#62; &#39;Songbird (\d\.\d)[\d\/]*?&#39;} =&#62; sub {
      &#39;foo method for songbird&#39;
    }

    get &#39;/foo&#39; =&#62; sub {
      &#39;all browsers except songbird&#39;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PREFIX"
>PREFIX</a></h2>

<p>A prefix can be defined for each route handler, like this:</p>

<pre>    prefix &#39;/home&#39;;</pre>

<p>From here, any route handler is defined to /home/*</p>

<pre>    get &#39;/page1&#39; =&#62; sub {}; # will match &#39;/home/page1&#39;</pre>

<p>You can unset the prefix value</p>

<pre>    prefix &#39;/&#39;; # or: prefix undef;
    get &#39;/page1&#39; =&#62; sub {}; will match /page1</pre>

<p>Alternatively, to prevent you from ever forgetting to undef the prefix, you can use lexical prefix like this:</p>

<pre>    prefix &#39;/home&#39; =&#62; sub {
      get &#39;/page1&#39; =&#62; sub {}; # will match &#39;/home/page1&#39;
    }; ## prefix reset to previous value on exit
    
    get &#39;/page1&#39; =&#62; sub {}; will match /page1</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACTION_SKIPPING"
>ACTION SKIPPING</a></h1>

<p>An action can choose not to serve the current request and ask Dancer to process the request with the next matching route.</p>

<p>This is done with the <b>pass</b> keyword, like in the following example</p>

<pre>    get &#39;/say/:word&#39; =&#62; sub {
        return pass if (params-&#62;{word} =~ /^\d+$/);
        &#34;I say a word: &#34;.params-&#62;{word};
    };

    get &#39;/say/:number&#39; =&#62; sub {
        &#34;I say a number: &#34;.params-&#62;{number};
    };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DEFAULT_ERROR_PAGES"
>DEFAULT ERROR PAGES</a></h2>

<p>When an error is rendered (the action responded with a status code different than 200), Dancer first looks in the public directory for an HTML file matching the error code (eg: 500.html or 404.html).</p>

<p>If such a file exists, it&#39;s used to render the error, otherwise, a default error page will be rendered on the fly.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="EXECUTION_ERRORS"
>EXECUTION ERRORS</a></h2>

<p>When an error occurs during the route execution, Dancer will render an error page with the HTTP status code 500.</p>

<p>It&#39;s possible either to display the content of the error message or to hide it with a generic error page.</p>

<p>This is a choice left to the end-user and can be set with the <b>show_errors</b> setting.</p>

<p>Note that you can also choose to consider all warnings in your route handlers as errors when the setting <b>warnings</b> is set to 1.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOOKS"
>HOOKS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Before_hooks"
>Before hooks</a></h2>

<p>Before hooks are evaluated before each request within the context of the request and can modify the request and response. It&#39;s possible to define variables which will be accessible in the action blocks with the keyword &#39;var&#39;.</p>

<pre>    hook &#39;before&#39; =&#62; sub {
        var note =&#62; &#39;Hi there&#39;;
        request-&#62;path_info(&#39;/foo/oversee&#39;)
    };

    get &#39;/foo/*&#39; =&#62; sub {
        my ($match) = splat; # &#39;oversee&#39;;
        vars-&#62;{note}; # &#39;Hi there&#39;
    };</pre>

<p>For another example, this can be used along with session support to easily give non-logged-in users a login page:</p>

<pre>    hook &#39;before&#39; =&#62; sub {
        if (!session(&#39;user&#39;) &#38;&#38; request-&#62;path_info !~ m{^/login}) {
            # Pass the original path requested along to the handler:
            var requested_path =&#62; request-&#62;path_info;
            request-&#62;path_info(&#39;/login&#39;);
        }
    };</pre>

<p>The request keyword returns the current Dancer::Request object representing the incoming request. See the documentation of the <a href="../../Dancer/Request.html" class="podlinkpod"
>Dancer::Request</a> module for details.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="After_hooks"
>After hooks</a></h2>

<p><code>after</code> hooks are evaluated after the response has been built by a route handler, and can alter the response itself, just before it&#39;s sent to the client.</p>

<p>The hook is given the response object as its first argument:</p>

<pre>    hook &#39;after&#39; =&#62; sub {
        my $response = shift;
        $response-&#62;{content} = &#39;after hook got here!&#39;;
    };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Before_template_hook"
>Before template hook</a></h2>

<p><code>before_template_render</code> hooks are called whenever a template is going to be processed, they are passed the tokens hash which they can alter.</p>

<pre>    hook &#39;before_template_render&#39; =&#62; sub {
        my $tokens = shift;
        $tokens-&#62;{foo} = &#39;bar&#39;;
    };</pre>

<p>The tokens hash will then be passed to the template with all the modifications performed by the hook. This is a good way to setup some global vars you like to have in all your templates, like the name of the user logged in or a section name.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONFIGURATION_AND_ENVIRONMENTS"
>CONFIGURATION AND ENVIRONMENTS</a></h1>

<p>Configuring a Dancer application can be done in many ways. The easiest one (and maybe the dirtiest) is to put all your settings statements at the top of your script, before calling the dance() method.</p>

<p>Other ways are possible, you can write all your setting calls in the file `appdir/config.yml&#39;. For this, you must have installed the YAML module, and of course, write the conffile in YAML.</p>

<p>That&#39;s better than the first option, but it&#39;s still not perfect as you can&#39;t switch easily from an environment to another without rewriting the config.yml file.</p>

<p>The better way is to have one config.yml file with default global settings, like the following:</p>

<pre>    # appdir/config.yml
    logger: &#39;file&#39;
    layout: &#39;main&#39;</pre>

<p>And then write as many environment files as you like in appdir/environments. That way, the appropriate environment config file will be loaded according to the running environment (if none is specified, it will be &#39;development&#39;).</p>

<p>Note that you can change the running environment using the --environment commandline switch.</p>

<p>Typically, you&#39;ll want to set the following values in a development config file:</p>

<pre>    # appdir/environments/development.yml
    log: &#39;debug&#39;
    startup_info: 1
    show_errors:  1</pre>

<p>And in a production one:</p>

<pre>    # appdir/environments/production.yml
    log: &#39;warning&#39;
    startup_info: 0
    show_errors:  0</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="load"
>load</a></h2>

<p>You can use the load method to include additional routes into your application:</p>

<pre>    get &#39;/go/:value&#39;, sub {
        # foo
    };

    load &#39;more_routes.pl&#39;;

    # then, in the file more_routes.pl:
    get &#39;/yes&#39;, sub {
        &#39;orly?&#39;;
    };</pre>

<p><b>load</b> is just a wrapper for <b>require</b>, but you can also specify a list of routes files:</p>

<pre>    load &#39;login_routes.pl&#39;, &#39;session_routes.pl&#39;, &#39;misc_routes.pl&#39;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_configuration_data"
>Accessing configuration data</a></h2>

<p>A Dancer application can access the information from its config file easily with the config keyword:</p>

<pre>    get &#39;/appname&#39; =&#62; sub {
        return &#34;This is &#34; . config-&#62;{appname};
    };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Importing_just_the_syntax"
>Importing just the syntax</a></h1>

<p>If you want to use more complex file hierarchies, you can import just the syntax of Dancer.</p>

<pre>    package App;

    use Dancer;            # App may contain generic routes
    use App::User::Routes; # user-related routes</pre>

<p>Then in App/User/Routes.pm:</p>

<pre>    use Dancer &#39;:syntax&#39;;

    get &#39;/user/view/:id&#39; =&#62; sub {
        ...
    };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LOGGING"
>LOGGING</a></h1>

<p>It&#39;s possible to log messages sent by the application. In the current version, only one method is possible for logging messages but future releases may add additional logging methods, for instance logging to syslog.</p>

<p>In order to enable the logging system for your application, you first have to start the logger engine in your config.yml</p>

<pre>    logger: &#39;file&#39;</pre>

<p>Then you can choose which kind of messages you want to actually log:</p>

<pre>    log: &#39;debug&#39;     # will log debug, warning, error and info messages
    log: &#39;info&#39;      # will log info, warning and error messages
    log: &#39;warning&#39;   # will log warning and error messages
    log: &#39;error&#39;     # will log error messages</pre>

<p>A directory appdir/logs will be created and will host one logfile per environment. The log message contains the time it was written, the PID of the current process, the message and the caller information (file and line).</p>

<p>To log messages, use the debug, info, warning and error functions. For instance:</p>

<pre>    debug &#34;This is a debug message&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_TEMPLATES"
>USING TEMPLATES</a></h1>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VIEWS"
>VIEWS</a></h1>

<p>It&#39;s possible to render the action&#39;s content with a template; this is called a view. The `appdir/views&#39; directory is the place where views are located.</p>

<p>You can change this location by changing the setting &#39;views&#39;, for instance if your templates are located in the &#39;templates&#39; directory, do the following:</p>

<pre>    set views =&#62; path(dirname(__FILE__), &#39;templates&#39;);</pre>

<p>By default, the internal template engine is used (<a href="../../Dancer/Template/Simple.html" class="podlinkpod"
>Dancer::Template::Simple</a>) but you may want to upgrade to Template::Toolkit. If you do so, you have to enable this engine in your settings as explained in <a href="../../Dancer/Template/TemplateToolkit.html" class="podlinkpod"
>Dancer::Template::TemplateToolkit</a>. If you do so, you&#39;ll also have to import the <a href="../../Template.html" class="podlinkpod"
>Template</a> module in your application code. Note that Dancer configures the Template::Toolkit engine to use &#60;% %&#62; brackets instead of its default [% %] brackets, although you can change this in your config file.</p>

<p>All views must have a &#39;.tt&#39; extension. This may change in the future.</p>

<p>In order to render a view, just call the &#39;template&#39; keyword at the end of the action by giving the view name and the HASHREF of tokens to interpolate in the view (note that the request, session and route params are automatically accessible in the view, named request, session and params):</p>

<pre>    use Dancer;
    use Template;

    get &#39;/hello/:name&#39; =&#62; sub {
        template &#39;hello&#39; =&#62; { number =&#62; 42 };
    };</pre>

<p>And the appdir/views/hello.tt view can contain the following code:</p>

<pre>   &#60;html&#62;
    &#60;head&#62;&#60;/head&#62;
    &#60;body&#62;
        &#60;h1&#62;Hello &#60;% params.name %&#62;&#60;/h1&#62;
        &#60;p&#62;Your lucky number is &#60;% number %&#62;&#60;/p&#62;
        &#60;p&#62;You are using &#60;% request.user_agent %&#62;&#60;/p&#62;
        &#60;% IF session.user %&#62;
            &#60;p&#62;You&#39;re logged in as &#60;% session.user %&#62;&#60;/p&#62;
        &#60;% END %&#62;
    &#60;/body&#62;
   &#60;/html&#62;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="LAYOUTS"
>LAYOUTS</a></h2>

<p>A layout is a special view, located in the &#39;layouts&#39; directory (inside the views directory) which must have a token named `content&#39;. That token marks the place where to render the action view. This lets you define a global layout for your actions. Any tokens that you defined when you called the &#39;template&#39; keyword are available in the layouts, as well as the standard session, request, and params tokens. This allows you to insert per-page content into the HTML boilerplate, such as page titles, current-page tags for navigation, etc.</p>

<p>Here is an example of a layout: views/layouts/main.tt:</p>

<pre>    &#60;html&#62;
        &#60;head&#62;&#60;% page_title %&#62;&#60;/head&#62;
        &#60;body&#62;
        &#60;div id=&#34;header&#34;&#62;
        ...
        &#60;/div&#62;

        &#60;div id=&#34;content&#34;&#62;
        &#60;% content %&#62;
        &#60;/div&#62;

        &#60;/body&#62;
    &#60;/html&#62;</pre>

<p>This layout can be used like the following:</p>

<pre>    use Dancer;
    set layout =&#62; &#39;main&#39;;

    get &#39;/&#39; =&#62; sub {
        template &#39;index&#39; =&#62; { page_title =&#62; &#34;Your website Homepage&#34; };
    };</pre>

<p>Of course, if a layout is set, it can also be disabled for a specific action, like the following:</p>

<pre>    use Dancer;
    set layout =&#62; &#39;main&#39;;

    get &#39;/nolayout&#39; =&#62; sub {
        template &#39;some_ajax_view&#39;,
            { tokens_var =&#62; &#34;42&#34; },
            { layout =&#62; 0 };
    };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="STATIC_FILES"
>STATIC FILES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="STATIC_DIRECTORY"
>STATIC DIRECTORY</a></h2>

<p>Static files are served from the ./public directory. You can specify a different location by setting the &#39;public&#39; option:</p>

<pre>    set public =&#62; path(dirname(__FILE__), &#39;static&#39;);</pre>

<p>Note that the public directory name is not included in the URL. A file ./public/css/style.css is made available as example.com/css/style.css.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="STATIC_FILE_FROM_A_ROUTE_HANDLER"
>STATIC FILE FROM A ROUTE HANDLER</a></h2>

<p>It&#39;s possible for a route handler to send a static file, as follows:</p>

<pre>    get &#39;/download/*&#39; =&#62; sub {
        my $params = shift;
        my ($file) = @{ $params-&#62;{splat} };

        send_file $file;
    };</pre>

<p>Or even if you want your index page to be a plain old index.html file, just do:</p>

<pre>    get &#39;/&#39; =&#62; sub {
        send_file &#39;/index.html&#39;
    };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SETTINGS"
>SETTINGS</a></h1>

<p>It&#39;s possible to change quite every parameter of the application via the settings mechanism.</p>

<p>A setting is key/value pair assigned by the keyword <b>set</b>:</p>

<pre>    set setting_name =&#62; &#39;setting_value&#39;;</pre>

<p>More usefully, settings can be defined in a YAML configuration file. Environment-specific settings can also be defined in environment-specific files (for instance, you don&#39;t want auto_reload in production, and might want extra logging in development). See the cookbook for examples.</p>

<p>See <a href="../../Dancer/Config.html" class="podlinkpod"
>Dancer::Config</a> for complete details about supported settings.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SERIALIZERS"
>SERIALIZERS</a></h1>

<p>When writing a webservice, data serialization/deserialization is a common issue to deal with. Dancer can automatically handle that for you, via a serializer.</p>

<p>When setting up a serializer, a new behaviour is authorized for any route handler you define: any non-scalar response will be rendered as a serialized string, via the current serializer.</p>

<p>Here is an example of a route handler that will return a HashRef</p>

<pre>    use Dancer;
    set serializer =&#62; &#39;JSON&#39;;

    get &#39;/user/:id/&#39; =&#62; sub {
        { foo =&#62; 42,
          number =&#62; 100234,
          list =&#62; [qw(one two three)],
        }
    };</pre>

<p>As soon as the content is not a scalar - and a serializer is set, which is not the case by default - Dancer renders the response via the current serializer.</p>

<p>Hence, with the JSON serializer set, the route handler above would result in a content like the following:</p>

<pre>    {&#34;number&#34;:100234,&#34;foo&#34;:42,&#34;list&#34;:[&#34;one&#34;,&#34;two&#34;,&#34;three&#34;]}</pre>

<p>The following serializers are available, be aware they dynamically depend on Perl modules you may not have on your system.</p>

<dl>
<dt><a name="JSON"
><b>JSON</b></a></dt>

<dd>
<p>requires <a href="../../JSON.html" class="podlinkpod"
>JSON</a></p>

<dt><a name="YAML"
><b>YAML</b></a></dt>

<dd>
<p>requires <a href="../../YAML.html" class="podlinkpod"
>YAML</a></p>

<dt><a name="XML"
><b>XML</b></a></dt>

<dd>
<p>requires <a href="../../XML/Simple.html" class="podlinkpod"
>XML::Simple</a></p>

<dt><a name="Mutable"
><b>Mutable</b></a></dt>

<dd>
<p>will try to find the appropriate serializer using the <b>Content-Type</b> and <b>Accept-type</b> header of the request.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLE"
>EXAMPLE</a></h1>

<p>This is a possible webapp created with Dancer:</p>

<pre>    #!/usr/bin/perl

    # make this script a webapp
    use Dancer;

    # declare routes/actions
    get &#39;/&#39; =&#62; sub {
        &#34;Hello World&#34;;
    };

    get &#39;/hello/:name&#39; =&#62; sub {
        &#34;Hello &#34;.param(&#39;name&#39;);
    };

    # run the webserver
    Dancer-&#62;dance;</pre>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
